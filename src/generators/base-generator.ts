import { ParsedNginxConfig, ServerBlock, LocationBlock } from '../core/config-model.js';

export abstract class BaseGenerator {
  protected config: ParsedNginxConfig;

  constructor(config: ParsedNginxConfig) {
    this.config = config;
  }

  /**
   * Generate the output configuration for the target platform
   */
  abstract generate(): string;

  /**
   * Get the file extension for the generated output
   */
  abstract getFileExtension(): string;

  /**
   * Validate that the nginx configuration can be converted to the target platform
   */
  validate(): { valid: boolean; warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    // Basic validation
    if (!this.config.servers || this.config.servers.length === 0) {
      errors.push('No server blocks found in configuration');
    }

    // Platform-specific validation
    const platformValidation = this.validatePlatformSpecific();
    warnings.push(...platformValidation.warnings);
    errors.push(...platformValidation.errors);

    return {
      valid: errors.length === 0,
      warnings,
      errors
    };
  }

  /**
   * Platform-specific validation logic
   */
  protected abstract validatePlatformSpecific(): { warnings: string[]; errors: string[] };

  /**
   * Helper method to extract hostname patterns from server_name
   */
  protected extractHostPatterns(server: ServerBlock): string[] {
    if (!server.server_name) {
      return ['*'];
    }
    return server.server_name;
  }

  /**
   * Helper method to determine if a location is a static file location
   */
  protected isStaticLocation(location: LocationBlock): boolean {
    return !!(
      location.directives.root ||
      location.directives.alias ||
      (!location.directives.proxy_pass && !location.directives.return)
    );
  }

  /**
   * Helper method to determine if a location is a proxy location
   */
  protected isProxyLocation(location: LocationBlock): boolean {
    return !!location.directives.proxy_pass;
  }

  /**
   * Helper method to determine if a location is a redirect location
   */
  protected isRedirectLocation(location: LocationBlock): boolean {
    return !!(
      location.directives.return ||
      (location.directives.rewrite && 
       location.directives.rewrite.some(rule => 
         rule.flags?.includes('redirect') || rule.flags?.includes('permanent')
       ))
    );
  }

  /**
   * Helper method to normalize path for URL matching
   */
  protected normalizePath(path: string): string {
    // Remove trailing slash unless it's the root path
    if (path !== '/' && path.endsWith('/')) {
      path = path.slice(0, -1);
    }
    return path;
  }

  /**
   * Helper method to convert nginx regex to JavaScript regex
   */
  protected convertNginxRegex(nginxRegex: string): string {
    // Basic conversion - this would need to be more sophisticated for production
    return nginxRegex
      .replace(/\$uri/g, '$1')
      .replace(/\$args/g, '$2')
      .replace(/\$request_uri/g, '$0');
  }

  /**
   * Helper method to extract SSL configuration
   */
  protected hasSSL(server: ServerBlock): boolean {
    return server.listen.some(listen => listen.ssl) || !!server.ssl;
  }

  /**
   * Helper method to get the primary domain from server_name
   */
  protected getPrimaryDomain(server: ServerBlock): string {
    if (!server.server_name || server.server_name.length === 0) {
      return 'localhost';
    }
    
    // Return the first non-wildcard domain, or the first domain if all are wildcards
    const nonWildcard = server.server_name.find(name => !name.includes('*'));
    return nonWildcard || server.server_name[0];
  }

  /**
   * Helper method to generate a comment header for the output
   */
  protected generateHeader(): string {
    const timestamp = new Date().toISOString();
    const sourceFile = this.config.metadata.source_file || 'unknown';
    
    return [
      `// Generated by nginx-to-edge-js v${this.config.metadata.parser_version}`,
      `// Source: ${sourceFile}`,
      `// Generated at: ${timestamp}`,
      `// Target platform: ${this.constructor.name}`,
      ''
    ].join('\n');
  }
}
